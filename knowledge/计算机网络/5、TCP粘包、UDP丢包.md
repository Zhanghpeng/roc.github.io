# 1 TCP粘包

## 1 什么时候考虑粘包

-   **如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题**（因为只有一种包结构,类似于http协议,UDP不会出现粘包现象）。关闭连接主要要双方都发送close连接（参考tcp关闭协议）。如：A需要发送一段字符串给B，那么A与B建立连接，然后发送双方都默认好的协议字符如"hello give me sth abour yourself"，然后B收到报文后，就将缓冲区数据接收,然后关闭连接，这样粘包问题不用考虑到，因为大家都知道是发送一段字符。
- **如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包**
- 如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构：
   1)"hello give me sth abour yourself" 
   2)"Don't give me sth abour yourself" 
     那这样的话，如果发送方连续发送这个两个包出去，接收方一次接收可能会是"hello give me sth abour yourselfDon't give me sth abour yourself" 这样接收方就傻了，到底是要干嘛？不知道，因为协议没有规定这么诡异的字符串，所以要处理把它分包，怎么分也需要双方组织一个比较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。

## 2 粘包出现的原因

  在流传输中会出现（如TCP），UDP不会出现粘包（数据报传输）

-   发送端需要等缓冲区满才发送出去，造成粘包  （nalge算法也可能造成粘包现象）
- TCP默认会使用Nagle算法。而**Nagle算法**主要做两件事：1）只有上一个分组得到确认，才会发送下一个分组；2）收集多个小分组，在一个确认到来时一起发送。所以，正是Nagle算法造成了发送方有可能造成粘包现象。
- 接收方不及时接收缓冲区的包，如果TCP接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，就会读到多个首尾相接粘到一起的包。

## 3 粘包解决的方法

- 一是对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；
- 由于发送发引起的可以使用TCP_NODELAY选项来关闭Nagle算法
- 二是对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
- 三是由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。
- 还有的笨方法是在两次send函数之间添加 sleep函数， 显然会降低数据传输效率

**以上提到的三种措施，都有其不足之处。**

- 第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。
- 第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。
- 第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。

## 4 解决粘包的工程方法

工程项目中，根据数据传输的特点，推荐两种可选择的方案：

-  添加标志字段，在每次发送数据是添加标记字段：

  A： size 标记数据长度的方式 

   B：特定标记字段标记数据的结尾（模仿帧的设计方式）结束符的方式

- . 定义应用层的数据通讯协议 ：如果数据按照一定的方式存储或着有加密的需求， 可以通过自己定制 数据通讯协议对数据封装，并实现自己的数据 封包｜ 拆包函数。

**细节：** 

1. 环形缓冲实现方案是定义两个指针,分别指向有效数据的头和尾.在存放数据和删除数据时只是进行头尾指针的移动.

# 2 UDP丢包

## 2.1 丢包的主要原因

- 接收端处理时间过长导致丢包：调用recv方法接收端收到数据后，处理数据花了一些时间，处理完后再次调用recv方法，在这二次调用间隔里，发过来的包可能丢失。对于这种情况可以修改接收端，将包接收后存入一个缓冲区，然后迅速返回继续recv.
- 发送的包较大，超过接受者缓存导致丢包：包超过mtu size数倍，几个大的udp包可能会超过接收者的缓冲，导致丢包
- 发送的包频率太快：虽然每个包的大小都小于mtu size 但是频率太快

## 2.2 解决方案

- 模拟tcp三次握手协议，通过使用Timer定时器监视发送请求后接受数据的时间，如果一段时间内没有接受到数据包则判定丢包，并重新发送本次请求
- 换TCP 