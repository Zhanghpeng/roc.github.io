[
  
  {
    "title": "设计模式之三",
    "url": "/posts/design-03/",
    "categories": "博客, 设计模式",
    "tags": "设计模式, 适配器模式, 装饰模式, 代理模式, 外观模式, 桥接模式, 组合模式, 享元模式",
    "date": "2020-08-10 14:10:00 +0800",
    





    
    "snippet": "设计模式上一篇为创建型模式，本篇包含以下几种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。1、适配器模式适配器模式（Adapter）将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题，主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。类的适配器模式核心思想就是：有一个Source类，拥有一个方法...",
    "content": "设计模式上一篇为创建型模式，本篇包含以下几种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。1、适配器模式适配器模式（Adapter）将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题，主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。类的适配器模式核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable,通过Adapter类，将Source的功能拓展到Targetable里，看代码：public class Source{  public void method1(){    System.out.println(\"this is original method);  }}public interface Targetable{  public void method1();//与原类中的方法相同  public void method2();//新类的方法}public class Adapter extends Source implements Targetable{  @Override  public void method2(){    System.out.println(\"this is the targetable method\");  }}public class AdapterTest { \tpublic static void main(String[] args) {\t\tTargetable target = new Adapter();\t\ttarget.method1();//this is original method!\t\ttarget.method2();//this is the targetable method!\t}}这样Targetable接口的实现类就具有了Source类的功能。对象的适配器模式基本思路和类适配器模式相同，只是将Adapter类修改，这次不继承Source类，而是持有source类的实例，以达到解决兼容性问题。只修改Adapter类，代码如下public class Wrapper implements Targetable {    private Source source;    public Wrapper(Source source) {        super();        this.source = source;    }    @Override    public void method1() {        System.out.println(\"this is the targetable method!\");    }    @Override    public void method2() {        source.method1();    }    public static void main(String[] args){        Targetable targetable = new Wrapper(new Source());        targetable.method1();//this is original method!        targetable.method2();//this is the targetable method!    }}输出于第一种一样，只是适配的方法不同接口的适配器模式他的内容是这样的：有事我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。代码如下：public interface Sourceable{  public void method1();  public void method2();}public abstract class Wrapper2 implements Sourceable{  public void method1(){};  public void method2(){};}public class SourceSub1 extends Wrapper2{  public void method1(){    System.out.println(\"the sourceable interface's first Sub1!\")  }}public class SourceSub2 extends Wrapper2 {\tpublic void method2(){\t\tSystem.out.println(\"the sourceable interface's second Sub2!\");\t}}适配器模式应用场景：  类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。  对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。  接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类，实现所有方法（方法体可以为空），放我们写别的类的时候继承抽象类即可。2、装饰模式顾名思义，装饰模式（Decorator）就是给一个对象增加一些新的功能，并且是动态的。要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。示例代码如下：public interface Sourceable{  public void method();}public class Source implements Sourceable{//Source类是被装饰类  @Override  public void method(){    System.out.println(\"the original method\");  }}public class Decorator implements Sourceable{//Decorator 类是装饰类可以为Source类动态的添加一些功能  private Sourceable source;  public Decorator(Sourceable source){    super();    this.source = source;  }  @Override  public void method(){    System.out.println(\"before decorator!\");\tsource.method();\tSystem.out.println(\"after decorator!\");  }}应用场景：  需要扩展一个类的功能  动态的为一个对象增加功能，而且还能动态撤销（继承不能做到这一点，继承的功能是静态的，不能动态增删）  缺点是：产生过多相似对象，不易排错。3、代理模式代理模式（Proxy）其实就是多一个代理类出来，替原对象进行一些操作。示例代码：public interface Sourceable{  public void method();}public class Source implements Sourceable { \t@Override\tpublic void method() {\t\tSystem.out.println(\"the original method!\");\t}}public class Proxy implements Sourceable{  private Source source;  public Proxy(){    super();    this.source = new Source();  }  @Override  public void method(){    before();    source.method();    after();  }  \tprivate void atfer() {\t\tSystem.out.println(\"after proxy!\");\t}\tprivate void before() {\t\tSystem.out.println(\"before proxy!\");\t}}应用场景：如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：  修改原来的方法来适应。这样违反了，“堆拓展开放，对修改关闭”的原则。  就是采用一个代理类嗲用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。  使用代理模式，可以将功能划分的更加清晰，有助于后期维护。4、外观模式外观模式（Facade）是为了解决类与类之间的依赖关系得到，像spring一样，可以将类与类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式没有涉及接口。public class CPU{  public void startup(){    System.out.println(\"cpu startup);  }}public class Memory {\t\tpublic void startup(){\t\tSystem.out.println(\"memory startup!\");\t}\t\tpublic void shutdown(){\t\tSystem.out.println(\"memory shutdown!\");\t}}public class Disk {\t\tpublic void startup(){\t\tSystem.out.println(\"disk startup!\");\t}\t\tpublic void shutdown(){\t\tSystem.out.println(\"disk shutdown!\");\t}}public class Computer {\tprivate CPU cpu;\tprivate Memory memory;\tprivate Disk disk;\t\tpublic Computer(){\t\tcpu = new CPU();\t\tmemory = new Memory();\t\tdisk = new Disk();\t}\t\tpublic void startup(){\t\tSystem.out.println(\"start the computer!\");\t\tcpu.startup();\t\tmemory.startup();\t\tdisk.startup();\t\tSystem.out.println(\"start computer finished!\");\t}\t\tpublic void shutdown(){\t\tSystem.out.println(\"begin to close the computer!\");\t\tcpu.shutdown();\t\tmemory.shutdown();\t\tdisk.shutdown();\t\tSystem.out.println(\"computer closed!\");\t}}public class User { \tpublic static void main(String[] args) {\t\tComputer computer = new Computer();\t\tcomputer.startup();\t\tcomputer.shutdown();\t}}如果我们没有Computer类，那么CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能要修改其他类。有了Computer类，他们之间的关系放在了这个类里，这样就起到了解耦的作用，这就是外观模式5、桥接模式桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，向我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要改动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。示例代码：public interface Sourceable{  public void method();}public class SourceSub1 implements Sourceable{  @Override  public void method(){    System.out.print(\"this is the first sub\")  }}public class SourceSub2 implements Sourceable{  @Override  public void method(){      System.out.println(\"this is the second sub!\");  }}public abstract class Bridge{  private Sourceable source;  public void method(){    source.method();  }  public Sourceable getSource(){    return source;  }  public void setSource(Sourceable source){    this.source = source;  }}public class MyBridge extends Bridge{  @Override  public void method(){    getSource().method();  }}public class BridgeTest{  public static void main(String[] args){    Bridge bridge = new Bridge();    Sourceable source1 = new SourceSub1();    bridge.method();//this is the first sub!    Sourceable source2 = new SourceSub2();    bridge.setSource(source2);    bridge.method();//this is the second sub!  }}6、组合模式组合模式（Composite）有时又叫部分-整体模式，在处理类似树形结构的问题时比较方便。示例代码：public class TreeNode{  private String name;  private TreeNode parent;  private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;();  public TreeNode(String name){    this.name = name;  }  public String getName(){    return name;  }  public void setName(String name){    this.name = name;  }  public TreeNode getParent(){    return parent;  }  public void setParent(){    this.parent = parent;  }    public void add(TreeNode node){    children.add(node);  }  public void remove(TreeNode node){    children.remove(node);  }  public Enumeration&lt;TreeNode&gt; getChildren(){    return children.elements();  }}public class Tree{  TreeNode root = null;  public Tree(String name){    root = new TreeNode(name);  }  public static void main(String[] args){    Tree tree = new Tree(\"A\");    TreeNode nodeB = new TreeNode(\"B\");    TreeNode nodeC = new TreeNode(\"C\");    nodeB.add(nodeC);    tree.root.add(nodeB);    System.out.println(\"build the tree finished!\");  }}使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，树等。7、享元模式享元模式（Flyweight)的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。FlyWeightFactory负责创建和管理享元单位，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类，一提到共享池，我们很容易联想到Java里面的JDBC连接池，想到每个连接的特点，我们不难总结出，适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池说，url、driverClassName、username、password及dbname，这些属性对于每一个连接来说都是一样的，所以就是和用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其他的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。看个例子：看下数据库连接池的代码：public class ConnectionPool {\t\tprivate Vector&lt;Connection&gt; pool;\t\t/*公有属性*/\tprivate String url = \"jdbc:mysql://localhost:3306/test\";\tprivate String username = \"root\";\tprivate String password = \"root\";\tprivate String driverClassName = \"com.mysql.jdbc.Driver\"; \tprivate int poolSize = 100;\tprivate static ConnectionPool instance = null;\tConnection conn = null; \t/*构造方法，做一些初始化工作*/\tprivate ConnectionPool() {\t\tpool = new Vector&lt;Connection&gt;(poolSize); \t\tfor (int i = 0; i &lt; poolSize; i++) {\t\t\ttry {\t\t\t\tClass.forName(driverClassName);\t\t\t\tconn = DriverManager.getConnection(url, username, password);\t\t\t\tpool.add(conn);\t\t\t} catch (ClassNotFoundException e) {\t\t\t\te.printStackTrace();\t\t\t} catch (SQLException e) {\t\t\t\te.printStackTrace();\t\t\t}\t\t}\t} \t/* 返回连接到连接池 */\tpublic synchronized void release() {\t\tpool.add(conn);\t} \t/* 返回连接池中的一个数据库连接 */\tpublic synchronized Connection getConnection() {\t\tif (pool.size() &gt; 0) {\t\t\tConnection conn = pool.get(0);\t\t\tpool.remove(conn);\t\t\treturn conn;\t\t} else {\t\t\treturn null;\t\t}\t}}通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！装饰模式、代理模式异同装饰模式：  再不改变接口的前提下，动态拓展对象的访问  动态继承，让类具有在运行期改变行为的能力  装饰模式，突出的是运行期增加行为，这和继承是不同的，继承是在编译期增加行为  强调:增强代理模式：  再不改变接口的前提下，控制对象的访问。  从封装的角度讲，是为了解决类与类之间相互调用而由此导致的耦合关系，可以说是几口的另外一个层引用。比如：在A类-&gt;B类代理-&gt;C类这个关系中，C类的一切行为都隐藏在b中，即调用者不知道要访问的内容与代理。  从复用的角度讲，可以解决不同类调用一个复杂类时，仅仅因较小的改变而导致整个复杂类新建一个类。比如：a类 -&gt; c类1； b类 -&gt;c类2；可以改变为a类-&gt; ca代理类 -&gt;c类；b类-&gt;cb代理类-c类。代理模式是类之间的封装和（某方面的）复用。  强调限制。"
  },
  
  {
    "title": "设计模式之二",
    "url": "/posts/design-02/",
    "categories": "博客, 设计模式",
    "tags": "设计模式, 策略模式, 模板方法模式, 观察者模式, 迭代子模式, 责任链模式, 命令模式, 备忘录模式, 状态模式, 访问者模式, 中介者模式, 解释器模式",
    "date": "2020-08-09 14:10:00 +0800",
    





    
    "snippet": "设计模式将会设计到第三种设计模式-行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。1、策略模式策略模式（strategy）定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户，需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设...",
    "content": "设计模式将会设计到第三种设计模式-行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。1、策略模式策略模式（strategy）定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户，需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设寄一个抽象类（可有可无，属于辅助类），提供辅助函数。示例代码：public interface ICalculator{//统一接口  public int calculate(String exp);}public abstract class AbstractCalculator{//辅助类  public int[] split(String exp,String opt){    String array[] = exp.split(opt);    int arrayInt[] = new int[2];    arrayInt[0] = Integer.parsentInt(array[0]);    arrayInt[1] = Integer.parsentInt(array[1]);    return arrayInt;  }}public class Plus extends AbstractCalcultor implements ICalulator{  @Override  public int calculate(String exp){    int arrayInt[] = split(exp,\"\\\\+\");    return arrayInt[0] +arrayInt[1];  }}public class Minus extends AbstractCalculator implements ICalculator { \t@Override\tpublic int calculate(String exp) {\t\tint arrayInt[] = split(exp,\"-\");\t\treturn arrayInt[0]-arrayInt[1];\t} }public class Multiply extends AbstractCalculator implements ICalculator { \t@Override\tpublic int calculate(String exp) {\t\tint arrayInt[] = split(exp,\"\\\\*\");\t\treturn arrayInt[0]*arrayInt[1];\t}}public class StrategyTest { \tpublic static void main(String[] args) {\t\tString exp = \"2+8\";\t\tICalculator cal = new Plus();\t\tint result = cal.calculate(exp);\t\tSystem.out.println(result);\t}}策略模式的决定权在用户，系统本身提供不同算法的的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定使用哪个算法即可。2、模板方法模式解释一下模板方法模式（Template Method）就是指：一个抽象类中，有一个主方法，在定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类继承该抽象类，重写抽象方法，通过调用抽象类实现对子类的调用。实例代码：就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用split（）等，Plus、Minus分贝继承AbstractCalculator类，通过对AbstractCalculator调用实现对子类的调用public abstract class AbstractCalculator{//抽象类  public final int calculate(String exp,String opt){//主方法，实现对本类其他方法的调用    int array[] = split(exp,opt);    return calculate(array[0],array[1]);  }  abstract public int calculate(int num1,int num2);//被子类重写的方法  public int[] split(String exp,String opt){    String array[] = exp.split(opt);    int arrayInt[] = new int[2];    arrayInt[0] = Integer.parsentInt(array[0]);    arrayInt[1] = Integer.parsentInt(array[1]);    return arrayInt;  }}public class Plus extends AbstractCalculator{  @Override  public int calculate(int num1,int num2){    return num1 + num2;  }}public class StrategyTest { \tpublic static void main(String[] args) {\t\tString exp = \"8+8\";\t\tAbstractCalculator cal = new Plus();\t\tint result = cal.calculate(exp, \"\\\\+\");\t\tSystem.out.println(result);\t}}3、观察者模式包括这个模式在内的接下来四个模式，都是类与类之间的关系，不涉及到继承，观察者模式（Observer）很好理解，尅私语邮件订阅和RSS订阅，当我们浏览一些博客或者wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如有后续更新，会及时通知你，其实简单来讲一句话，当一个对象变化时，其他依赖该对象的对象都会收到通知，并且随之变化，对象之间是一种一对多的关系。实例代码：MySubject类时我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然发生变化，AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改，增加或者删除被监控对象，且当MySubject变化时，负责通知列表内存在的对象。public interface Observer{//一个Observer接口  public void update();}public class Observer1 implements Observer{  @Override  public void update(){    System.out.println(\"observer1 has received!\");  }}public class Observer2 implements Observer { \t@Override\tpublic void update() {\t\tSystem.out.println(\"observer2 has received!\");\t} }/** *Subject接口及实现类 */public interface Subject{  public void add(Observer observer);//增加观察者  public void del(Observer observer);//删除观察者  public void notifyObservers();//通知所有的观察者  public void operation();//自身的操作}public abstract class AbstractSubject implements Subject{  private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;();  @Override\tpublic void add(Observer observer) {\t\tvector.add(observer);\t} \t@Override\tpublic void del(Observer observer) {\t\tvector.remove(observer);\t}\t@Override   public void notifyObservers(){    Enumeration&lt;Observer&gt; enumo = vector.elements();    while(enumo.hasMoreElements()){      enumo.nextElement().update();    }  }}public class MySubject extends AbstractSubject{  @Override  public void operation(){    System.out.print(\"update self!\");    notifyObservers();  }}public class ObserverTest { \tpublic static void main(String[] args) {\t\tSubject sub = new MySubject();\t\tsub.add(new Observer1());\t\tsub.add(new Observer2());\t\t\t\tsub.operation();\t} }4、迭代子模式顾名思义，迭代器模式（Iterator）就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式十分轻松。这句话包含两层意思：  一是需要遍历的对象即聚集对象  二是迭代器对象，用于对聚集对象进行遍历访问实例代码：MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例。public interface Collection{  public Iterator iterator();  Object get(int i);//取得集合元素  public int size();//取得集合大小}public interface Iterator{  Object previous();  Object next();  boolean hasNext();  Object first();//取得第一个元素}public class MyCollection implements Collection{  public String string[] = {\"A\",\"B\",\"C\",\"D\",\"E\"};\t@Override\tpublic Iterator iterator() {\t\treturn new MyIterator(this);\t}\t@Override\tpublic Object get(int i) {\t\treturn string[i];\t} \t@Override\tpublic int size() {\t\treturn string.length;\t}}public class MyIterator implements Iterator{  private Collection collection;  private int pos = -1;  public MyIterator(Collection collection){    this.collcection = collection  }  \t@Override\tpublic Object previous() {\t\tif(pos &gt; 0){\t\t\tpos--;\t\t}\t\treturn collection.get(pos);\t}  @Override\tpublic Object next() {\t\tif(pos&lt;collection.size()-1){\t\t\tpos++;\t\t}\t\treturn collection.get(pos);\t}@Override\tpublic boolean hasNext() {\t\tif(pos&lt;collection.size()-1){\t\t\treturn true;\t\t}else{\t\t\treturn false;\t\t}\t}@Override\tpublic Object first() {\t\tpos = 0;\t\treturn collection.get(pos);\t}}public class Test { \tpublic static void main(String[] args) {\t\tCollection collection = new MyCollection();\t\tIterator it = collection.iterator();\t\t\t\twhile(it.hasNext()){\t\t\tSystem.out.println(it.next());\t\t}\t}}5、责任链模式责任链模式（Chain of Responsibility）有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，知道某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以责任链模式可以实现，再隐瞒客户端的情况下，对系统进行动态的调整。示例代码：Abstracthandle类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle是核心，实例化后生成一系列相互持有的对象，构成一条链。public interface Handler{  public void operator();}public abstract class AbstractHandler {  private Handler handler;  public Handler getHandler(){    return Handler;  }  public void setHandler(Handler handler) {\tthis.handler = handler;  }}public class MyHandler extends AbstractHandler implements Handler{  private String name;  private MyHandler(String name){    this.name = name;  }  @Override  pubic void operator(){    System.out.println(name + \"deal\");    if(getHandler()!=null){      getHandler.operator();    }  }}public class Test { \tpublic static void main(String[] args) {\t\tMyHandler h1 = new MyHandler(\"h1\");\t\tMyHandler h2 = new MyHandler(\"h2\");\t\tMyHandler h3 = new MyHandler(\"h3\"); \t\th1.setHandler(h2);\t\th2.setHandler(h3); \t\th1.operator();\t}}链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许有一个对象传给另一个对象，而不允许传给多个对象。6、命令模式命令模式（Command）很好理解，举个例子，司令员下令让士兵去干件事情从整个事情的角度考虑，司令员的作用是，发出口令，口令经过传递传到了士兵耳朵里，士兵去执行，这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要管好自己的事情。司令员只要结果，而不管士兵如何实现。示例代码：Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接受对象。public interface Command{  void exe();}public class MyCommand implements Command{  private Receiver receiver;  public MyCommand(Receiver receiver){    this,receiver = receiver;  }  @Override  public void exe(){    receiver.action();  }}pubic class Receiver{  public void action(){    System.out.println(\"command received!\");  }}public class Invoker{  private Command command;  public Invoker (Command command){    this command = command;  }  public void action(){    command.exe();  }}public class Test { \tpublic static void main(String[] args) {\t\tReceiver receiver = new Receiver();\t\tCommand cmd = new MyCommand(receiver);\t\tInvoker invoker = new Invoker(cmd);\t\tinvoker.action();\t}}7、备忘录模式备忘录模式（Memento）主要目的是保存一个对象的某个状态,以便在适当的适合恢复对象。假设有原始类A,A中有各种属性，A可以决定需要背负的属性，备忘录类B是用来存储A的的一些内部状态，类C呢就是一个用来存储备忘录的，且只能存储，不能修改等操作。实例代码：Original类时原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值，Memento类是备忘录类，Storage类是存储备忘录的类，持有Mementopublic class Original{  private String value;  public String getValue(){    return value;  }  public void setValue(String value){    this.value = value;  }  public Memento createMemento(){    return new Memento(value);  }  \tpublic void restoreMemento(Memento memento){\t\tthis.value = memento.getValue();\t}}public class Memento {\t\tprivate String value; \tpublic Memento(String value) {\t\tthis.value = value;\t} \tpublic String getValue() {\t\treturn value;\t} \tpublic void setValue(String value) {\t\tthis.value = value;\t}}public class Storage {\t\tprivate Memento memento;\t\tpublic Storage(Memento memento) {\t\tthis.memento = memento;\t} \tpublic Memento getMemento() {\t\treturn memento;\t} \tpublic void setMemento(Memento memento) {\t\tthis.memento = memento;\t}}public class Test { \tpublic static void main(String[] args) {\t\t\t\t// 创建原始类\t\tOriginal origi = new Original(\"egg\"); \t\t// 创建备忘录\t\tStorage storage = new Storage(origi.createMemento()); \t\t// 修改原始类的状态\t\tSystem.out.println(\"初始化状态为：\" + origi.getValue());\t\torigi.setValue(\"niu\");\t\tSystem.out.println(\"修改后的状态为：\" + origi.getValue()); \t\t// 回复原始类的状态\t\torigi.restoreMemento(storage.getMemento());\t\tSystem.out.println(\"恢复后的状态为：\" + origi.getValue());\t}}8、状态模式状态模式（State）核心思想就是：当对象的状态改变时，同时改变其行为，就拿QQ来说有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态。所以状态模式就两点：  可以通过改变状态来获得不同的行为  你的好友能同时看到你的变化。实例代码：State类是个状态类，Context类可以实现切换。public class State {\t\tprivate String value;\t\tpublic String getValue() {\t\treturn value;\t} \tpublic void setValue(String value) {\t\tthis.value = value;\t} \tpublic void method1(){\t\tSystem.out.println(\"execute the first opt!\");\t}\t\tpublic void method2(){\t\tSystem.out.println(\"execute the second opt!\");\t}}public class Context { \tprivate State state; \tpublic Context(State state) {\t\tthis.state = state;\t} \tpublic State getState() {\t\treturn state;\t} \tpublic void setState(State state) {\t\tthis.state = state;\t} \tpublic void method() {\t\tif (state.getValue().equals(\"state1\")) {\t\t\tstate.method1();\t\t} else if (state.getValue().equals(\"state2\")) {\t\t\tstate.method2();\t\t}\t}}public class Test { \tpublic static void main(String[] args) {\t\t\t\tState state = new State();\t\tContext context = new Context(state);\t\t\t\t//设置第一种状态\t\tstate.setValue(\"state1\");\t\tcontext.method();\t\t\t\t//设置第二种状态\t\tstate.setValue(\"state2\");\t\tcontext.method();\t}}9、访问者模式访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对性自由的演化，访问者模式使用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易，若系统数据结构对象抑郁变化，经常有新的数据对象增加进来，则不适合使用访问者模式，访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据接口。其缺点是增加新的数据结构很困难。简单来说，访问者模式（Visitor）就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态的添加新的操作而无需做其他修改的效果。实例代码：public interface Visitor{  public void visit(Subject sub);}public class MyVisitor implements Visitor{  @Override  public void visit(Subject sub){    System.out.println(\"visit the subject\"+sub.getSubject());  }}public interface Subject{  public void accept(Visitor visitor);  public String getSubject();}public class Mysubject implemets Subject{  @OVerride  public ovid accept(Visitor visitor){    visitor.visit(this);  }  @Override  public String getSubject(){    return \"love\";  }}public class Test { \tpublic static void main(String[] args) {\t\t\t\tVisitor visitor = new MyVisitor();\t\tSubject sub = new MySubject();\t\tsub.accept(visitor);\t\t}}该模式使用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情  新功能会不会与现有的功能出现兼容性问题  以后会不会在需要再添加？  如果类不允许修改代码怎么办面对这些问题，最好的解决方式就是访问者者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦10、中介者模式中介者模式（Mediator）也是用来降低类类之间的耦合的，如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其他关联的对象都得进行修改，如果使用中介者模式，只需要关心和Mediator类的关系，有点像spring容器的作用。实例代码：public interface Mediator{  void createMediator();  void workAll();}public class MyMediator implements Mediator { \tprivate User user1;\tprivate User user2;\t\tpublic User getUser1() {\t\treturn user1;\t} \tpublic User getUser2() {\t\treturn user2;\t} \t@Override\tpublic void createMediator() {\t\tuser1 = new User1(this);\t\tuser2 = new User2(this);\t} \t@Override\tpublic void workAll() {\t\tuser1.work();\t\tuser2.work();\t}}public abstract class User {\t\tprivate Mediator mediator;\t\tpublic Mediator getMediator(){\t\treturn mediator;\t}\t\tpublic User(Mediator mediator) {\t\tthis.mediator = mediator;\t} \tpublic abstract void work();}public class User1 extends User { \tpublic User1(Mediator mediator){\t\tsuper(mediator);\t}\t\t@Override\tpublic void work() {\t\tSystem.out.println(\"user1 exe!\");\t}}public class User2 extends User { \tpublic User2(Mediator mediator){\t\tsuper(mediator);\t}\t\t@Override\tpublic void work() {\t\tSystem.out.println(\"user2 exe!\");\t}}public class Test { \tpublic static void main(String[] args) {\t\tMediator mediator = new MyMediator();\t\tmediator.createMediator();\t\tmediator.workAll();\t}}11、解释器模式解释器（Interpreter）主要应用在OOP的编辑器的开发中实例代码：public interface Expression{  public int interpret(Context context);}public class Plus implements Expression { \t@Override\tpublic int interpret(Context context) {\t\treturn context.getNum1()+context.getNum2();\t}}public class Minus implements Expression { \t@Override\tpublic int interpret(Context context) {\t\treturn context.getNum1()-context.getNum2();\t}}public class Context {\t\tprivate int num1;\tprivate int num2;\t\tpublic Context(int num1, int num2) {\t\tthis.num1 = num1;\t\tthis.num2 = num2;\t}\t\tpublic int getNum1() {\t\treturn num1;\t}\tpublic void setNum1(int num1) {\t\tthis.num1 = num1;\t}\tpublic int getNum2() {\t\treturn num2;\t}\tpublic void setNum2(int num2) {\t\tthis.num2 = num2;\t}}public class Test { \tpublic static void main(String[] args) { \t\t// 计算9+2-8的值\t\tint result = new Minus().interpret((new Context(new Plus()\t\t\t\t.interpret(new Context(9, 2)), 8)));\t\tSystem.out.println(result);\t}}"
  },
  
  {
    "title": "设计模式之一",
    "url": "/posts/design-01/",
    "categories": "博客, 设计模式",
    "tags": "设计模式, 工厂模式, 单例模式, 建造者模式, 原型模式",
    "date": "2020-08-08 14:10:00 +0800",
    





    
    "snippet": "设计模式​\t设计模式是一套被反复使用，多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让带吗更容易被他人理解、保证代码可靠性。毫无疑问，设计模式与己与他人系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，没有个模式描述了一个...",
    "content": "设计模式​\t设计模式是一套被反复使用，多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让带吗更容易被他人理解、保证代码可靠性。毫无疑问，设计模式与己与他人系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，没有个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。设计模式分类总体来说设计模式分为三大类：      创建型模式，共五种：工厂方式模式、抽象工厂模式、单例模式、建造者模式、原型模式。    对象实例化的模式，创建型模式用于解耦对象的实例化过程。        结构型模式，共七种：适配器模式、桥接模式、装饰器模式、代理模式、外观模式、组合模式、亨元模式。    把类和对象结合在一起形成一个更大的结构        行为型模式：共十一中：策略模式、模板方法模式、观察模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。    类和对象如何交互，及划分责任和算法。  设计模式的六大原则  开闭原则：(Open Close Principle)对拓展开放、对修改关闭。就是说在程序需要拓展时不能修改原代码。想达到这种效果，需要使用接口和抽象类。  里式代换原则：(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。其中说，任何基类可以出现的地方，子类一定可以出现，LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不收到影响时，基类才能真正被复用，而衍生类也能够在积累的基础上增加新的行为。LSP是对“开-闭”原则的补充。原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现。所以LSP是对实现抽象化的具体步骤的规范。  依赖倒转原则:(Dependence Inversion Principle)这个是开闭原则的基础，具体内容是针对接口编程，依赖于抽象而不依赖于具体。  接口隔离原则:(Interface Segregation Principle)使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了生计和维护方便。所以上文中多次出现：降低依赖，降低耦合。  迪米特法则：(最少知道法则,Demeter Principle)为什么叫最少知道原则，就是说一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。  合成复用原则：(Composite Reuse Principle)原则是尽量使用合成/聚合的方式，而不是使用继承。Java中的23种设计模式1、工厂模式①普通工厂模式，就是建立一个工厂类，堆实现了同一个接口的一些类进行实例的创建（示例代码如下）。public interface Sender{//基类  public void Send();}public class MailSender implements Sender{//子类  @Override  public void Send(){    System.out.println(\"this is mailsender\");  }}public class SmsSender implements Sender{//子类  @Override  public void Send(){    System.out.println(\"this is smssender\");  }}public class SendFactory{//工厂类  public Sender produce(String type){    if(\"mail\".equals(type)){      return new MailSender();    }else if(\"sms\".equals(type)){      return new SmsSender();    }else {      System.out.println(\"请输入正确的类型\");\t  return null;    }  }}②对个工厂方法模式，就是对普通工厂模式方法的改进，在普通工厂方法模式中，如果过传递的字符串出租哦，则不能正确的创建对象，而多个工厂方法模式就是提供多个工厂发放，分别创建对象。所①代码进行修改public class SendFactory{  public Sender produceMail(){    return new MailSender();  }  public Sender produceSms(){    return new SmsSender();  }}③静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。public class SendFactory{  public static Sender produceMail(){    return new MailSender();  }  public static Sender produceSms(){    return new SmsSender();  }}总的来说，工厂模式适合凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种字符串传入有误，不能正确创建对象，第三种相对于第二种不需要实例化工厂类。所以大多数情况下选择静态工厂方法模式。2、抽象工厂模式工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题。如何解决就用到了抽象工厂模式（Abstract Factory）创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改原来的代码。看下面代码public interface Provider(){//将工厂模式中的SendFactory变成接口  public abstract Sender Send();//interface 默认是抽象的，abstrace可以不带，请注意}public class SendMailFactory implments Provider{//一个类一个功能  @Override  public Sender Send(){    return new MailSender();  }}public class SendSMSFactory implements Provider{  @Override  public Sender Send(){    return new SmsSender();  }}这个模式的好处就是，如果过你现在想增加一个功能，如发及时消息，则只需要做一个实现类，实现Sender接口,同时做一个工厂类，实现Provider接口，就OK了，无需改动现成的代码。这样做拓展性较好。3、单例模式单例对象（Singleton）是一种常用的设计模式,在Java应用中，单例对象能保证在一个Jvm中，该对象只有一个实例存在。这样的模式有几个好处：  某些类的创建比较频繁，对于一些大型的对象，这是一笔很大的开销。  省去了new操作符，降低了系统内存的使用频率，减轻GC压力。  有些类如交易所的核心交易引擎，控制着交易流程，如果过该类可以创建多个的话，系统就乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱）代码示例如下：public class Singleton{  /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */  private static Singleton instance = null;  /* 私有构造方法，防止被实例化 */  private Singleton(){  }  /* 静态工程方法，创建实例 */  public static Singleton getInstance(){    if(instance == null){      instance = new Singleton();    }    return instance;    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */    public Object readResolve(){      return instance;    }  }}这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？public static synchronized Singleton getInstance(){  if(instance == null){    instance = new Singleton();  }  return instance;}但是，synchronized 关键字锁住的是这个对象，这样的用法，在性能上有所下降，因为每次调用getInstance()都要在对象上佳作，事实上，只有第一次创建对象的时候需要佳作，之后就不需要了，所以这个地方需要改进，我们改成下面这个：public static Singleton get Instance(){  if(instance == null){    synchronized(instance){      if(instance == null){        instance = new Singleton();      }    }  }  return instance;}上面的做法似乎解决了问题，性能相比以上有一定提升，但是还是有可能有问题的。在Java指令中，创建对象和赋值操作时分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不能保证这两个操作的先后顺序，也就是说JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再进行初始化Singleton实例。这样就可能出错了。所以我们对程序进行进一步优化。private static class SingletonFactory{  private static Singleton instance = new Singleton();}public static Singleton getInstance(){  return SingletonFactory.instance;}实际情况是，单例模式使用内部类来维护单例的实现 ，jvm内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题，下面是一个较完美的单例模式：public class Singleton { \t/* 私有构造方法，防止被实例化 */\tprivate Singleton() {\t} \t/* 此处使用一个内部类来维护单例 */\tprivate static class SingletonFactory {\t\tprivate static Singleton instance = new Singleton();\t} \t/* 获取实例 */\tpublic static Singleton getInstance() {\t\treturn SingletonFactory.instance;\t} \t/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */\tpublic Object readResolve() {\t\treturn getInstance();\t}}其实说他完美，也不一定。如果在构造函数中抛出异常，实例永远也得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。下面也是可以的public class SingletonTest { \tprivate static SingletonTest instance = null; \tprivate SingletonTest() {\t} \tprivate static synchronized void syncInit() {\t\tif (instance == null) {\t\t\tinstance = new SingletonTest();\t\t}\t} \tpublic static SingletonTest getInstance() {\t\tif (instance == null) {\t\t\tsyncInit();\t\t}\t\treturn instance;\t}}补充采用影子实例的办法为单例对象的属性同步更新public class SingletonTest{  private static SingletonTest instance = null;  private Vector properties = null;  public Vector getProperties(){    return properties;  }  private SingletonTest(){     }  private static synchronized void syncInit(){    if(instance == null){      instance = new SingletonTest();    }  }  public static singletonTest getInstance(){    if(instance == null){      syncInit();    }    return instance;  }    public void updateProperties(){    SingletonTest shadow = new SingletonTest();    properties = shadow.getProperties();  }}4、建造者模式工厂类模式提供的是创建单个类的模式，而建造者模式（Builder）则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是勤勉的抽象工程模式和最后的Test结合起来得到的。我们看一下代码：还和前面一样，一个Sender接口，两个实现类,MailSender和SmsSender最后建造者类如下：public class Builder{  private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;();  public void produceMailSender(int count){    for(int i = 0 ;i&lt;count;i++){      list.add(new MailSender());    }  }  public void produceSmsSender(int count){    for(int i = 0;i&lt;count;i++){      list.add(new SmsSender);    }  }}从这点可以看出，建造者模式讲很多功能集成到一个类里，这个类可以创造出比较负载的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。一次，是选择工厂模式还是建造者模式，以实际情况而定。5、原型模式原型模式（Prototype）虽然是创建型的模式，但是与工程模式没哟关系，从名字即可看出，该模式的思想就是讲一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。在Java中复制对象是通过clone()实现的，先创建一个原型类：public class Prototype implements Cloneable{  @Override  public Object clone throws CloneNotSuipportedException{    ProtoType proto = (Prototype)super.clone();    return proto;  }}一个原型类只需要实现Cloneable接口，重点是super.clone()，在Object类中 clone()是native的。具体怎么实现需要结合浅复制和深复制来说一下：  浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指的。  深复制：将一个对象复制后，无论基本数据类型还是引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。深浅复制例子：public class Prototype implements Cloneable,Serializable{  private static final long serialVersionUID = 1L;  private String string;  private SerializableObject obj;  @Override  public Object clone() throws CloneNotSupportedException{//浅复制    Prototype proto = (Prototype)super.clone();    return proto;  }  public Object deepClone() throws IOException,ClassNotFoundException{//深复制    ByteArrayOutputStream bos = new ByteArrayOutputStream();//写入当前对象的二进制流    ObjectOutputStream oos = new ObjectOutputStream(bos);    oos.writeObject(this);    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray);//读出二进制流产生的新对象    ObjectInputStream ois = new ObjectInputStream(bis);    return ois.readObject();  }  public String getString() {\t\treturn string;\t} \tpublic void setString(String string) {\t\tthis.string = string;\t} \tpublic SerializableObject getObj() {\t\treturn obj;\t} \tpublic void setObj(SerializableObject obj) {\t\tthis.obj = obj;\t}}class SerializableObject implements Serializable {\tprivate static final long serialVersionUID = 1L;}要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。"
  }
  
]

